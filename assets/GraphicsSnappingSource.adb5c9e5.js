import{bz as C,cY as z,ov as F,p_ as k,m9 as E,m8 as G,jl as H,jj as W,m7 as L,jE as T,p$ as j,q0 as B,q1 as S,cs as D,M as Q,lk as U,O as y,q2 as V,V as J,cw as X,pN as Y,H as Z,bq as K,fA as ee,at as te,p2 as se,ko as ie,J as x,K as g,L as re,ie as ae}from"./vendor.c28ea743.js";import{m as ne}from"./FeatureStore.c47b839a.js";import{V as oe}from"./QueryEngine.127c8abc.js";import{o as ce}from"./queryEngineUtils.5ae682f5.js";import"./PooledRBush.8877f027.js";import"./quickselect.02d2bace.js";import"./optimizedFeatureQueryEngineAdapter.fb87930e.js";import"./QueryEngineCapabilities.650d7541.js";import"./PointSnappingHint.439445c9.js";function de(e){if(!e)return null;let t=null;const i=e.spatialReference,s=z(i);if(!s)return"toJSON"in e?e.toJSON():e;const r=F(i)?102100:4326,a=k[r].maxX,n=k[r].minX,u=k[r].plus180Line,l=k[r].minus180Line;let m;const o="toJSON"in e?e.toJSON():e;if(E(o))m=N(o,a,n);else if(G(o))o.points=o.points.map(c=>N(c,a,n)),m=o;else if(H(o))m=le(o,s);else if(W(o)||L(o)){const c=he;T(c,o);const d={xmin:c[0],ymin:c[1],xmax:c[2],ymax:c[3]},p=S(d.xmin,n)*(2*a),h=p===0?o:me(o,p);d.xmin+=p,d.xmax+=p,j(d,u)&&d.xmax!==a||j(d,l)&&d.xmin!==n?t=h:m=h}else m=o;return t!==null?new ue().cut(t,a):m}function me(e,t){const i=B(e);for(const s of i)for(const r of s)r[0]+=t;return e}function le(e,t){if(!t)return e;const i=pe(e,t).map(s=>s.extent);return i.length<2?i[0]||e:i.length>2?(e.xmin=t.valid[0],e.xmax=t.valid[1],e):{rings:i.map(s=>[[s.xmin,s.ymin],[s.xmin,s.ymax],[s.xmax,s.ymax],[s.xmax,s.ymin],[s.xmin,s.ymin]])}}function N(e,t,i){if(Array.isArray(e)){const s=e[0];if(s>t){const r=S(s,t);e[0]=s+r*(-2*t)}else if(s<i){const r=S(s,i);e[0]=s+r*(-2*i)}}else{const s=e.x;if(s>t){const r=S(s,t);e.x+=r*(-2*t)}else if(s<i){const r=S(s,i);e.x+=r*(-2*i)}}return e}function pe(e,t){const i=[],{ymin:s,ymax:r}=e,a=e.xmax-e.xmin,n=e.xmin,u=e.xmax;let l;const[m,o]=t.valid;l=P(e.xmin,t);const c=l.x,d=l.frameId;l=P(e.xmax,t);const p=l.x,h=l.frameId,q=c===p&&a>0;if(a>2*o){const M={xmin:n<u?c:p,ymin:s,xmax:o,ymax:r},A={xmin:m,ymin:s,xmax:n<u?p:c,ymax:r},R={xmin:0,ymin:s,xmax:o,ymax:r},b={xmin:m,ymin:s,xmax:0,ymax:r},_=[],v=[];O(M,R)&&_.push(d),O(M,b)&&v.push(d),O(A,R)&&_.push(h),O(A,b)&&v.push(h);for(let w=d+1;w<h;w++)_.push(w),v.push(w);i.push({extent:M,frameIds:[d]},{extent:A,frameIds:[h]},{extent:R,frameIds:_},{extent:b,frameIds:v})}else c>p||q?i.push({extent:{xmin:c,ymin:s,xmax:o,ymax:r},frameIds:[d]},{extent:{xmin:m,ymin:s,xmax:p,ymax:r},frameIds:[h]}):i.push({extent:{xmin:c,ymin:s,xmax:p,ymax:r},frameIds:[d]});return i}function P(e,t){const[i,s]=t.valid,r=2*s;let a,n=0;return e>s?(a=Math.ceil(Math.abs(e-s)/r),e-=a*r,n=a):e<i&&(a=Math.ceil(Math.abs(e-i)/r),e+=a*r,n=-a),{x:e,frameId:n}}function O(e,t){const{xmin:i,ymin:s,xmax:r,ymax:a}=t;return I(e,i,s)&&I(e,i,a)&&I(e,r,a)&&I(e,r,s)}function I(e,t,i){return t>=e.xmin&&t<=e.xmax&&i>=e.ymin&&i<=e.ymax}class ue{cut(t,i){let s;if(t.rings)this.closed=!0,s=t.rings,this.minPts=4;else{if(!t.paths)return null;this.closed=!1,s=t.paths,this.minPts=2}const r=s.length,a=-2*i;for(let n=0;n<r;n++){const u=s[n];if(u&&u.length>=this.minPts){const l=[];for(const m of u)l.push([m[0]+a,m[1]]);s.push(l)}}return this.closed?t.rings=s:t.paths=s,t}}const he=C();let f=class extends D(Q){constructor(e){super(e),this.availability=1,this.sources={multipoint:null,point:null,polygon:null,polyline:null},this.loadedWkids=new Set,this.loadedWkts=new Set,this.pendingAdds=[]}get updating(){return this.updatingHandles.updating}get layer(){return this.layerSource.layer}destroy(){const e=this.pendingAdds;this.pendingAdds.length=0;for(const t of e)t.task.abort();this._mapSources(t=>this._destroySource(t))}initialize(){this.handles.add([this.layer.on("graphic-update",e=>this._onGraphicUpdate(e)),this.updatingHandles.addOnCollectionChange(()=>this.layer.graphics,e=>this._onGraphicsChanged(e))]),this._addMany(this.layer.graphics.toArray())}async fetchCandidates(e,t){const i=await U(this._mapSources(r=>r.queryEngine.executeQueryForSnapping({point:e.coordinateHelper.vectorToPoint(e.point).toJSON(),distance:e.distance,types:e.types,query:y(e.filter)?e.filter.createQuery().toJSON():{where:"1=1"}},t).then(({candidates:a})=>a))),s=i.flat().map(r=>ce(r,e.coordinateHelper));return V(e.point,s),s}refresh(){}_onGraphicUpdate(e){switch(e.property){case"geometry":case"visible":this._remove(e.graphic),this._addMany([e.graphic])}}_onGraphicsChanged(e){for(const t of e.removed)this._remove(t);this._addMany(e.added)}_addMany(e){const t=[],i=new Map;for(const s of e)J(s.geometry)||(this._needsInitializeProjection(s.geometry.spatialReference)?(t.push(s.geometry.spatialReference),i.set(s.uid,s)):this._add(s));this._createPendingAdd(t,i)}_createPendingAdd(e,t){if(!e.length)return;const i=X(async a=>{await Y(e.map(n=>({source:n,dest:this.spatialReference})),{signal:a}),this._markLoadedSpatialReferences(e);for(const[,n]of t)this._add(n)});this.updatingHandles.addPromise(i.promise);const s={task:i,graphics:t},r=()=>ae(this.pendingAdds,s);i.promise.then(r,r),this.pendingAdds.push(s)}_markLoadedSpatialReferences(e){for(const t of e)t.wkid!=null&&this.loadedWkids.add(t.wkid),t.wkt!=null&&this.loadedWkts.add(t.wkt)}_add(e){if(J(e.geometry)||!e.visible)return;let t=e.geometry;if(t.type==="mesh")return;t.type==="extent"&&(t=Z.fromExtent(t));const i=this._ensureSource(t.type);if(J(i))return;const s=this._createOptimizedFeature(e.uid,t);y(s)&&i.featureStore.add(s)}_needsInitializeProjection(e){return(e.wkid==null||!this.loadedWkids.has(e.wkid))&&(e.wkt==null||!this.loadedWkts.has(e.wkt))&&!K(e,this.spatialReference)}_createOptimizedFeature(e,t){const i=ee(de(t),this.spatialReference);return i?new te(se(i,!1,!1),{[$]:e},null,e):null}_ensureSource(e){const t=this.sources[e];if(y(t))return t;const i=this._createSource(e);return this.sources[e]=i,i}_createSource(e){const t=ie.toJSON(e),i=new ne({geometryType:t,hasZ:!1,hasM:!1});return{featureStore:i,queryEngine:new oe({featureStore:i,fields:[{name:$,type:"esriFieldTypeOID",alias:$}],geometryType:t,hasM:!1,hasZ:!1,objectIdField:$,spatialReference:this.spatialReference,scheduler:y(this.view)&&this.view.type==="3d"?this.view.resourceController.scheduler:null}),type:e}}_remove(e){this._mapSources(t=>this._removeFromSource(t,e));for(const t of this.pendingAdds)t.graphics.delete(e.uid),t.graphics.size===0&&t.task.abort()}_removeFromSource(e,t){const i=t.uid;e.featureStore.has(i)&&e.featureStore.removeById(t.uid)}_destroySource(e){e.queryEngine.destroy(),this.sources[e.type]=null}_mapSources(e){const{point:t,polygon:i,polyline:s,multipoint:r}=this.sources,a=[];return y(t)&&a.push(e(t)),y(i)&&a.push(e(i)),y(s)&&a.push(e(s)),y(r)&&a.push(e(r)),a}};x([g({constructOnly:!0})],f.prototype,"spatialReference",void 0),x([g({constructOnly:!0})],f.prototype,"layerSource",void 0),x([g({constructOnly:!0})],f.prototype,"view",void 0),x([g({readOnly:!0})],f.prototype,"updating",null),x([g({readOnly:!0})],f.prototype,"availability",void 0),f=x([re("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")],f);const $="OBJECTID";export{f as GraphicsSnappingSource};
