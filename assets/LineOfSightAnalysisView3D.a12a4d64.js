var vt=Object.defineProperty,yt=Object.defineProperties;var mt=Object.getOwnPropertyDescriptors;var tt=Object.getOwnPropertySymbols;var _t=Object.prototype.hasOwnProperty,Ct=Object.prototype.propertyIsEnumerable;var et=(t,e,i)=>e in t?vt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,F=(t,e)=>{for(var i in e||(e={}))_t.call(e,i)&&et(t,i,e[i]);if(tt)for(var i of tt(e))Ct.call(e,i)&&et(t,i,e[i]);return t},W=(t,e)=>yt(t,mt(e));import{J as n,K as o,l as d,L as x,M as j,aM as y,aB as ft,ap as gt,E as bt,aQ as it,G as X,b2 as M,nl as Ot,aJ as w,O as c,cb as N,cc as nt,bi as J,bh as Q,V as f,fd as Tt,e7 as D,j as Y,nm as ot,hS as st,my as rt,ih as wt,nb as Lt,ez as at,cJ as $,aa as C,ar as lt,bD as Vt,nn as ct,no as St,ac as U,cv as ut,b3 as z,f4 as Pt,aL as At,P as dt,ab as V,eJ as It,eI as Et,cw as Rt,np as zt,Z as H,mQ as q,cS as P,e4 as Dt,cs as $t,a9 as Ht,hs as xt}from"./vendor.c28ea743.js";import{p as jt}from"./AnalysisView3D.1c8e19f7.js";let O=class extends j{constructor(t){super(t),this.innerWidth=2,this.outerWidth=8,this.visibleInnerColor=new d([3,252,111,1]),this.visibleOuterColor=new d([3,252,111,.15]),this.occludedInnerColor=new d([252,3,69,1]),this.occludedOuterColor=new d([252,3,69,.1]),this.undefinedInnerColor=new d([255,255,255,1]),this.undefinedOuterColor=new d([127,127,127,.2])}};n([o({type:Number})],O.prototype,"innerWidth",void 0),n([o({type:Number})],O.prototype,"outerWidth",void 0),n([o({type:d})],O.prototype,"visibleInnerColor",void 0),n([o({type:d})],O.prototype,"visibleOuterColor",void 0),n([o({type:d})],O.prototype,"occludedInnerColor",void 0),n([o({type:d})],O.prototype,"occludedOuterColor",void 0),n([o({type:d})],O.prototype,"undefinedInnerColor",void 0),n([o({type:d})],O.prototype,"undefinedOuterColor",void 0),O=n([x("esri.views.3d.analysis.LineOfSight.LineOfSightConfiguration")],O);let A=class extends j{constructor(t){super(t),this.target=null,this.intersectedGraphic=null,this.intersectedLocation=null,this.elevationAlignedTargetLocation=null}};n([o()],A.prototype,"target",void 0),n([o()],A.prototype,"intersectedGraphic",void 0),n([o()],A.prototype,"intersectedLocation",void 0),n([o()],A.prototype,"elevationAlignedTargetLocation",void 0),n([o()],A.prototype,"visible",void 0),A=n([x("esri.views.3d.analysis.LineOfSightAnalysisResult")],A);let I=class extends j{constructor(t){super(t),this.elevationAlignedTargetLocation=null,this.inputPoints={isValid:!1,observer:y(),observerSurfaceNormal:null,target:y(),targetSurfaceNormal:null,observerAdjusted:y(),targetAdjusted:y()},this.computationResult={start:y(),end:y(),intersection:y(),isValid:!1,isTargetVisible:!1},this.result=null}notifyResultChanged(){this.notifyChange("computationResult")}notifyInputPointsChanged(){this.notifyChange("inputPoints")}};n([o()],I.prototype,"target",void 0),n([o()],I.prototype,"elevationAlignedTargetLocation",void 0),n([o()],I.prototype,"inputPoints",void 0),n([o()],I.prototype,"computationResult",void 0),n([o()],I.prototype,"result",void 0),I=n([x("esri.views.3d.analysis.LineOfSight.LineOfSightComputation")],I);const pt=ft.getLogger("esri.views.3d.analysis.LineOfSight.LineOfSightController");let m=class extends gt.EventedMixin(j){constructor(t){super(t),this.updateOnCameraChange=!0,this._updatingHandles=new bt,this._frameTask=it,this._handles=new X,this._computationHandles=new X,this._externalObserverUpdate=!0}initialize(){var t;const e=(t=this.view.resourceController)==null?void 0:t.scheduler;this._frameTask=e?e.registerTask(M.LINE_OF_SIGHT_TOOL):it,this._intersector=new Ot({view:this.view}),this._handles.add([this._connectObserver(),this._connectComputations(),this._connectTargets()])}destroy(){this._handles.destroy(),this._computationHandles.destroy(),this._computations.removeAll(),this._updatingHandles.destroy()}get updating(){return this._frameTask.updating||this._updatingHandles.updating}get priority(){return this._frameTask.priority}set priority(t){this._frameTask.priority=t}get _computations(){return this.analysisViewData.computations}get _observerEngineLocation(){return this.analysisViewData.observerEngineLocation}set _observerEngineLocation(t){this.analysisViewData.observerEngineLocation=t}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}getLineOfSightComputationDependencies(t){const{inputPoints:e}=t;return{inputPoints:e}}_computeResult(t){const e=t.computation,{inputPoints:i,computationResult:s}=e,{observerAdjusted:r,targetAdjusted:u}=i,{start:l,end:p}=s;w(l,r),w(p,u),this._canCompute(e)?this._computeIntersection(t):this._interpolateIntersection(t),e.notifyResultChanged(),this.emit("result-changed",{target:t.computation.target,result:e.result})}_adjustStartEndPositions(t){const e=this._screenPixelSize,i=this.view,{inputPoints:s}=t,{observer:r,observerSurfaceNormal:u,target:l,targetSurfaceNormal:p,observerAdjusted:h,targetAdjusted:T}=s,a=K;c(u)?w(a,u):N(a,l,r);const v=e;nt(a,a),J(a,a,Math.min(v,1)),Q(h,r,a),c(p)?w(a,p):N(a,r,l);const E=i.state.camera.computeScreenPixelSizeAt(l);nt(a,a),J(a,a,Math.min(E,1)),Q(T,l,a)}_computeIntersection({computation:t,interpolationInfo:e}){const{view:i}=this,{sceneIntersectionHelper:s,renderCoordsHelper:r}=i;if(f(s))return;const u=this._intersector.intersector,{computationResult:l,inputPoints:p}=t,{observer:h,target:T}=p,{start:a,end:v}=l,E=Tt(a,v,Nt);s.intersectToolIntersectorRay(E,u);const S=l.intersection,G=K;let g=!0;if(u.results.min.getIntersectionPoint(S)){w(e.originalIntersection,S),w(e.originalObserver,a),w(e.originalTarget,v),r.fromRenderCoords(S,G,i.spatialReference);const b=1-D(v,T)/D(a,T);g=D(h,S)>=b*D(h,T)}const R=new Y(G,i.spatialReference);{const{result:b,target:B}=t;c(b)?(b.target=B,b.intersectedGraphic=g?null:ot(u.results.min,i),b.intersectedLocation=g?null:R,b.visible=g):t.result=new A({target:B,elevationAlignedTargetLocation:t.elevationAlignedTargetLocation,intersectedGraphic:g?null:ot(u.results.min,i),intersectedLocation:g?null:R,visible:g})}l.isValid=p.isValid=!0,l.isTargetVisible=g}_interpolateIntersection({computation:t,interpolationInfo:e}){const{computationResult:i,inputPoints:s}=t,{start:r,end:u,intersection:l}=i,{originalIntersection:p,originalObserver:h,originalTarget:T}=e;if(w(l,p),s.isValid){const a=K,v=D(h,p)/D(h,T);st(a,r,h),J(a,a,1-v),Q(l,l,a),st(a,u,T),J(a,a,v),Q(l,l,a),i.isValid=!0}else t.result=null,i.isValid=!1,i.isTargetVisible=!1}_canCompute(t){const e=this.analysisViewData.elevationAlignedObserver,i=this.view.frustum;if(f(e)||f(t.elevationAlignedTargetLocation)||f(i))return!1;const{observerAdjusted:s,targetAdjusted:r}=t.inputPoints,u=i.intersectsPoint(s),l=i.intersectsPoint(r);return u&&l}_onObserverPositionChange(t,e,i){if(this._externalObserverUpdate=i,f(t))return void(this.analysisViewData.elevationAlignedObserver=null);const s=this._applyProjectionAndElevationAlignment(t,e);if(f(s))return rt(this.analysis,t.spatialReference,pt),void(this.analysisViewData.elevationAlignedObserver=null);const r=y();this.analysisViewData.elevationAlignedObserver=s,this.view.renderCoordsHelper.toRenderCoords(this.analysisViewData.elevationAlignedObserver,r),this._observerEngineLocation=r,this.priority=M.LINE_OF_SIGHT_TOOL_INTERACTIVE}_applyProjectionAndElevationAlignment(t,e){const i=c(e)&&e.type!==wt.OBJECT;return Lt(t,this.view.spatialReference,this.view.elevationProvider,i)}_onObserverRenderSpacePositionChangeForComputation(t,e,i){const{inputPoints:s}=t;if(w(s.observer,e),c(i)){const r=this._intersector.updateFromIntersectionResult(i);c(r)&&this.view.renderCoordsHelper.toRenderCoords(r,s.observer),s.observerSurfaceNormal=at(i.normal)}else s.observerSurfaceNormal=null;this._adjustStartEndPositions(t),t.notifyInputPointsChanged(),this.priority=M.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetPositionChange(t,e,i,s=!0){const r=t.inputPoints;if(s&&(r.isValid=!1),t.elevationAlignedTargetLocation=this._applyProjectionAndElevationAlignment(e,i),f(t.elevationAlignedTargetLocation))rt(this.analysis,e.spatialReference,pt);else{if(this.view.renderCoordsHelper.toRenderCoords(t.elevationAlignedTargetLocation,r.target),c(i)){const u=this._intersector.updateFromIntersectionResult(i);c(u)&&this.view.renderCoordsHelper.toRenderCoords(u,r.target),r.targetSurfaceNormal=at(i.normal)}else r.targetSurfaceNormal=null;this._adjustStartEndPositions(t)}t.notifyInputPointsChanged(),this.priority=M.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectComputationToTarget(t){return $([C(()=>t.target.position,e=>{ht(e,t.target.intersection)||(t.target.intersection=null)},dt),C(()=>({computation:t,targetPosition:t.target.position,targetIntersection:t.target.intersection}),({computation:e,targetPosition:i,targetIntersection:s})=>{c(i)&&this._onTargetPositionChange(e,i,s)},V)])}_connectComputationToObserver(t){return C(()=>({computation:t,observer:this.analysisViewData.elevationAlignedObserver}),({computation:e})=>{this._externalObserverUpdate&&(e.inputPoints.isValid=!1,e.notifyInputPointsChanged())},V)}_connectComputationToRenderSpaceObserver(t){return C(()=>({computation:t,observer:this._observerEngineLocation,observerIntersection:c(this.analysis.observer)?this.analysis.observer.intersection:null}),({computation:e,observer:i,observerIntersection:s})=>{this._onObserverRenderSpacePositionChangeForComputation(e,i,s)},V)}_connectComputationToCamera(t){return C(()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty}),({isDirty:e})=>{!this.updateOnCameraChange||t.inputPoints.isValid&&!e||t.notifyInputPointsChanged()},It)}_connectComputationToSlicePlane(t){return C(()=>this.view.slicePlane,()=>t.notifyInputPointsChanged())}_connectComputationToElevation(t){return this.view.elevationProvider.on("elevation-change",e=>{const i=this.analysis.observer,s=t.target;let r=null,u=null,l=null,p=null;const h=c(i)&&c(i.position)?i.position.spatialReference:c(s.position)?s.position.spatialReference:e.spatialReference;c(i)&&c(i.position)&&(r=Ut,u=i.intersection,lt(i.position,r,h)),c(s.position)&&(l=Bt,p=s.intersection,lt(s.position,l,h)),f(r)&&f(l)||(Vt(e.extent,e.spatialReference,Z,h),c(r)&&ct(Z,r)&&this._onObserverPositionChange(r,u,!1),c(l)&&ct(Z,l)&&this._onTargetPositionChange(t,l,p,!1),c(r)&&c(l)&&St(Z,r,l)&&t.notifyInputPointsChanged())})}_connectComputationToTask(t){let e=Et;const i={computation:t,interpolationInfo:{originalIntersection:y(),originalObserver:y(),originalTarget:y()}};return $([C(()=>this.getLineOfSightComputationDependencies(t),()=>{e=ut(e),e=Rt(async s=>{await zt(this._frameTask.schedule(()=>this._computeResult(i),s))})},V),U(()=>e=ut(e))])}_connectComputation(t){const e=this._computationHandles;e.has(t)||e.add([this._connectComputationToTarget(t),this._connectComputationToObserver(t),this._connectComputationToRenderSpaceObserver(t),this._connectComputationToCamera(t),this._connectComputationToSlicePlane(t),this._connectComputationToElevation(t),this._connectComputationToTask(t)],t)}_disconnectAnalysis(t){this._computationHandles.remove(t)}_onComputationCollectionChange(t){t.added.forEach(e=>this._connectComputation(e)),t.removed.forEach(e=>this._disconnectAnalysis(e))}_onTargetsChange(){return this._computations.removeAll(),this.analysis.targets.forEach(t=>this._addTarget(t)),this._updatingHandles.addOnCollectionChange(()=>this.analysis.targets,t=>this._onTargetCollectionChange(t))}_onTargetCollectionChange(t){t.added.forEach(e=>this._addTarget(e)),t.removed.forEach(e=>this._removeTarget(e))}_onCursorTargetChange(t,e){c(e)&&this._removeTarget(e),c(t)&&this._addTarget(t)}_addTarget(t){this._computations.some(e=>e.target===t)||this._computations.add(new I({target:t}))}_removeTarget(t){const e=this._computations.find(i=>i.target===t);this._computations.remove(e)}_connectObserver(){return $([C(()=>({observer:this.analysis.observer,observerPosition:c(this.analysis.observer)?this.analysis.observer.position:null,observerIntersection:c(this.analysis.observer)?this.analysis.observer.intersection:null}),({observer:t,observerPosition:e,observerIntersection:i})=>{c(t)&&!ht(e,i)&&(t.intersection=null)},dt),C(()=>({observerPosition:c(this.analysis.observer)?this.analysis.observer.position:null,observerIntersection:c(this.analysis.observer)?this.analysis.observer.intersection:null}),({observerPosition:t,observerIntersection:e})=>this._onObserverPositionChange(t,e,!0),V)])}_connectComputations(){let t=null;return $([C(()=>this._computations,()=>{z(t),t=this._updatingHandles.addOnCollectionChange(()=>this._computations,e=>this._onComputationCollectionChange(e)),this._computations.forEach(e=>this._connectComputation(e))},V),U(()=>t=z(t))])}_connectTargets(){let t=null;return $([C(()=>this.analysis.targets,()=>{t=z(t),t=this._onTargetsChange()},V),C(()=>this.analysisViewData.cursorTarget,(e,i)=>{this._onCursorTargetChange(e,i)}),U(()=>{t=z(t)})])}get _isCameraDirty(){const t=this.analysisViewData.elevationAlignedObserver,{view:e}=this,{renderCoordsHelper:i}=e;if(f(t)||f(i))return!1;const s=K;i.toRenderCoords(t,s);const r=e.state.camera.computeScreenPixelSizeAt(s);return Math.abs((r-this._screenPixelSize)/this._screenPixelSize)>Gt}};function ht(t,e){return f(e)||c(t)&&t.equals(e.point)}n([o({constructOnly:!0})],m.prototype,"analysis",void 0),n([o({constructOnly:!0})],m.prototype,"analysisViewData",void 0),n([o({constructOnly:!0})],m.prototype,"view",void 0),n([o()],m.prototype,"updating",null),n([o()],m.prototype,"priority",null),n([o()],m.prototype,"updateOnCameraChange",void 0),n([o()],m.prototype,"_computations",null),n([o()],m.prototype,"_observerEngineLocation",null),n([o()],m.prototype,"_screenPixelSize",null),n([o({readOnly:!0})],m.prototype,"_updatingHandles",void 0),n([o()],m.prototype,"_frameTask",void 0),n([o()],m.prototype,"_isCameraDirty",null),m=n([x("esri.views.3d.analysis.LineOfSight.LineOfSightController")],m);const Gt=.1,K=y(),Nt=Pt(),Z=At(),Ut=new Y,Bt=new Y;let L=class extends j{constructor(t){super(t),this._lineOfSightVisualizations=[],this._handle=null,this._computationHandles=new X}initialize(){this._handle=this._connectAnalysis()}destroy(){this._handle=z(this._handle),this._computationHandles=H(this._computationHandles)}get visible(){return this.analysisViewData.visible}get testInfo(){return{visualizations:this._lineOfSightVisualizations}}get _configuration(){return this.analysisViewData.configuration}createLineOfSightVisualization(){const t=this._configuration,e={view:this.view,attached:!0,width:t.outerWidth,innerWidth:t.innerWidth},i=d.toUnitRGBA(t.visibleOuterColor),s=d.toUnitRGBA(t.visibleInnerColor),r=d.toUnitRGBA(t.occludedOuterColor),u=d.toUnitRGBA(t.occludedInnerColor),l=d.toUnitRGBA(t.undefinedOuterColor),p=d.toUnitRGBA(t.undefinedInnerColor),h={visibleLineVisualElement:new q(W(F({},e),{color:i,innerColor:s})),occludedLineVisualElement:new q(W(F({},e),{color:r,innerColor:u})),undefinedLineVisualElement:new q(W(F({},e),{color:l,innerColor:p}))};return this._lineOfSightVisualizations.push(h),h}destroyLineOfSightVisualization(t){t.visibleLineVisualElement=H(t.visibleLineVisualElement),t.occludedLineVisualElement=H(t.occludedLineVisualElement),t.undefinedLineVisualElement=H(t.undefinedLineVisualElement),this._lineOfSightVisualizations.splice(this._lineOfSightVisualizations.indexOf(t),1)}updateLineOfSightVisualization(t,e){const i=this._configuration,{computationResult:s,inputPoints:r}=t,{start:u,end:l,intersection:p,isValid:h,isTargetVisible:T}=s,{observer:a}=r,v=Mt;v[12]=a[0],v[13]=a[1],v[14]=a[2];const E=N(kt,u,a),S=N(Ft,l,a),G=N(Wt,p,a),{visibleLineVisualElement:g,occludedLineVisualElement:R,undefinedLineVisualElement:b}=e,B=f(this.analysisViewData.elevationAlignedObserver)||f(t.elevationAlignedTargetLocation),k=this.visible&&!B;g.visible=k,R.visible=k,b.visible=k,k&&(g.geometry=null,R.geometry=null,b.geometry=null,h?T?(g.geometry=[[P(E),P(S)]],g.transform=v,g.color=d.toUnitRGBA(i.visibleOuterColor)):(g.geometry=[[P(E),P(G)]],g.transform=v,g.color=d.toUnitRGBA(i.occludedOuterColor),R.geometry=[[P(G),P(S)]],R.transform=v):(b.geometry=[[P(E),P(S)]],b.transform=v))}getLineOfSightVisualizationDependencies(t){const{computationResult:e}=t,{occludedOuterColor:i,visibleOuterColor:s}=this._configuration;return{computationResult:e,occludedOuterColor:i,visibleOuterColor:s,visible:this.visible}}_connectComputation(t){const e=this._computationHandles;if(e.has(t))return;const i=this.createLineOfSightVisualization();e.add([C(()=>this.getLineOfSightVisualizationDependencies(t),()=>this.updateLineOfSightVisualization(t,i),V),U(()=>this.destroyLineOfSightVisualization(i))],t)}_disconnectComputation(t){this._computationHandles.remove(t)}_connectAnalysis(){let t=null;return $([C(()=>this.analysisViewData.computations,e=>{t=z(t),t=e.on("change",i=>this._onComputationsCollectionChange(i)),this._onComputationsCollectionChange({target:e,added:e.items,removed:[],moved:[]})},V),U(()=>t=z(t))])}_onComputationsCollectionChange(t){t.added.forEach(e=>this._connectComputation(e)),t.removed.forEach(e=>this._disconnectComputation(e))}};n([o({constructOnly:!0})],L.prototype,"analysis",void 0),n([o({constructOnly:!0})],L.prototype,"analysisViewData",void 0),n([o({constructOnly:!0})],L.prototype,"view",void 0),n([o({readOnly:!0})],L.prototype,"visible",null),n([o()],L.prototype,"testInfo",null),n([o()],L.prototype,"_configuration",null),L=n([x("esri.views.3d.analysis.LineOfSight.LineOfSightVisualization")],L);const kt=y(),Ft=y(),Wt=y(),Mt=Dt();let _=class extends jt($t(gt.EventedMixin(j))){constructor(t){super(t),this.type="line-of-sight-view-3d",this.computations=new Ht,this.elevationAlignedObserver=null,this.configuration=new O,this.observerEngineLocation=y(),this.cursorTarget=null}initialize(){const t=this.view,e=this.analysis;this._analysisController=new m({analysis:e,analysisViewData:this,view:t}),this._analysisVisualization=new L({analysis:e,analysisViewData:this,view:t}),this.handles.add([this._analysisController.on("result-changed",i=>{i.target!==this.cursorTarget&&this.emit("result-changed",i)})])}destroy(){this._analysisController=H(this._analysisController),this._analysisVisualization=H(this._analysisVisualization)}get results(){return this.computations.map(t=>t.result)}get priority(){return this._analysisController.priority}set priority(t){this._analysisController.priority=t}get updating(){return c(this._analysisController)&&this._analysisController.updating}getResultForTarget(t){const e=this.computations.find(i=>i.target===t);return xt(e,i=>i.result)}get testInfo(){return{visualization:this._analysisVisualization,controller:this._analysisController}}};n([o()],_.prototype,"type",void 0),n([o()],_.prototype,"analysis",void 0),n([o({readOnly:!0})],_.prototype,"results",null),n([o()],_.prototype,"priority",null),n([o()],_.prototype,"computations",void 0),n([o()],_.prototype,"elevationAlignedObserver",void 0),n([o()],_.prototype,"configuration",void 0),n([o()],_.prototype,"observerEngineLocation",void 0),n([o()],_.prototype,"cursorTarget",void 0),n([o()],_.prototype,"updating",null),n([o()],_.prototype,"_analysisController",void 0),n([o()],_.prototype,"_analysisVisualization",void 0),_=n([x("esri.views.3d.analysis.LineOfSightAnalysisView3D")],_);const Zt=_;export{Zt as default};
