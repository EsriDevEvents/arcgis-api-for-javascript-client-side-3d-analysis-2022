import{J as u,K as g,L as G,iO as S,aM as E,cP as Y,e2 as q,eE as U,e8 as V,hT as L,e4 as m,hV as b,oD as f,hK as z,hA as j,e0 as k,oE as A,bC as C,oF as D,eo as J,oG as K,j as H,O as d,dk as Q,oH as W,ez as w,ea as X,oI as Z,oJ as O,V as h,oK as T,oL as y,oM as tt,oN as nt,oO as et,aE as rt,mT as ot,hU as at,oP as it,oQ as lt,oR as st,oS as ct,oT as pt,oU as ut}from"./vendor.c28ea743.js";import{a as N,l as gt,x as ht}from"./axisAngleDegrees.fc4feeae.js";var v;let p=v=class extends S{constructor(t){super(t),this.origin=E(),this.translation=E(),this.rotation=N(),this.scale=Y(1,1,1),this.geographic=!0}get localMatrix(){const t=m();return q(t,this.scale),U(t,t,ht(this.rotation),gt(this.rotation)),V(t,t,this.translation),t}get localMatrixInverse(){return L(m(),this.localMatrix)}applyLocal(t,e){return b(e,t,this.localMatrix)}applyLocalInverse(t,e){return b(e,t,this.localMatrixInverse)}project(t,e){const n=new Float64Array(t.length),r=f.fromTypedArray(n),o=f.fromTypedArray(t);if(this.geographic){const l=z(e),c=m();return j(e,this.origin,c,l),k(c,c,this.localMatrix),A(r,o,c),C(n,l,0,n,e,0,n.length/3),n}const{localMatrix:a,origin:i}=this;D(a,J)?K(r,o):A(r,o,a);for(let l=0;l<n.length;l+=3)n[l+0]+=i[0],n[l+1]+=i[1],n[l+2]+=i[2];return n}getOriginPoint(t){const[e,n,r]=this.origin;return new H({x:e,y:n,z:r,spatialReference:t})}equals(t){return d(t)&&this.geographic===t.geographic&&Q(this.origin,t.origin)&&W(this.localMatrix,t.localMatrix)}clone(){const t={origin:w(this.origin),translation:w(this.translation),rotation:N(this.rotation),scale:w(this.scale),geographic:this.geographic};return new v(t)}};u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"origin",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"translation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"rotation",void 0),u([g({type:[Number],nonNullable:!0,json:{write:!0}})],p.prototype,"scale",void 0),u([g({type:Boolean,nonNullable:!0,json:{write:!0}})],p.prototype,"geographic",void 0),u([g()],p.prototype,"localMatrix",null),u([g()],p.prototype,"localMatrixInverse",null),p=v=u([G("esri.geometry.support.MeshTransform")],p);const ft=p;function x(t,e){var n;return t.isGeographic||t.isWebMercator&&((n=e==null?void 0:e.geographic)==null||n)}function P(t,e,n){return x(e.spatialReference,n)?Tt(t,e,n):At(t,e,n)}function yt(t,e,n){const{position:r,normal:o,tangent:a}=t;if(h(e))return{position:r,normal:o,tangent:a};const i=e.localMatrix;return P({position:ct(r,new Float64Array(r.length),i),normal:d(o)?pt(o,new Float32Array(o.length),i):null,tangent:d(a)?ut(a,new Float32Array(a.length),i):null},e.getOriginPoint(n),{geographic:e.geographic})}function Nt(t,e,n){if(n!=null&&n.useTransform){var r;const{position:o,normal:a,tangent:i}=t;return{vertexAttributes:{position:o,normal:a,tangent:i},transform:new ft({origin:[e.x,e.y,(r=e.z)!=null?r:0],geographic:x(e.spatialReference,n)})}}return{vertexAttributes:P(t,e,n),transform:null}}function mt(t,e,n){return x(e.spatialReference,n)?B(t,e,n):M(t,e,n)}function Lt(t,e,n,r){if(h(e))return mt(t,n,r);const o=yt(t,e,n.spatialReference);return n.equals(e.getOriginPoint(n.spatialReference))?M(o,n,r):x(n.spatialReference,r)?B(o,n,r):M(o,n,r)}function At(t,e,n){const r=new Float64Array(t.position.length),o=t.position,a=e.x,i=e.y,l=e.z||0,{horizontal:c,vertical:$}=R(n?n.unit:null,e.spatialReference);for(let s=0;s<o.length;s+=3)r[s+0]=o[s+0]*c+a,r[s+1]=o[s+1]*c+i,r[s+2]=o[s+2]*$+l;return{position:r,normal:t.normal,tangent:t.tangent}}function Tt(t,e,n){const r=e.spatialReference,o=I(e,n,F),a=new Float64Array(t.position.length),i=xt(t.position,o,r,a),l=O(_,o);return{position:i,normal:$t(i,a,t.normal,l,r),tangent:wt(i,a,t.tangent,l,r)}}function xt(t,e,n,r){A(f.fromTypedArray(r),f.fromTypedArray(t),e);const o=new Float64Array(t.length);return Z(r,o,n)}function $t(t,e,n,r,o){if(h(n))return null;const a=new Float32Array(n.length);return T(y.fromTypedArray(a),y.fromTypedArray(n),r),tt(a,t,e,o,a),a}function wt(t,e,n,r,o){if(h(n))return null;const a=new Float32Array(n.length);T(y.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT),y.fromTypedArray(n,4*Float32Array.BYTES_PER_ELEMENT),r);for(let i=3;i<a.length;i+=4)a[i]=n[i];return nt(a,t,e,o,a),a}function M(t,e,n){const r=new Float64Array(t.position.length),o=t.position,a=e.x,i=e.y,l=e.z||0,{horizontal:c,vertical:$}=R(n?n.unit:null,e.spatialReference);for(let s=0;s<o.length;s+=3)r[s+0]=(o[s+0]-a)/c,r[s+1]=(o[s+1]-i)/c,r[s+2]=(o[s+2]-l)/$;return{position:r,normal:t.normal,tangent:t.tangent}}function B(t,e,n){const r=e.spatialReference;I(e,n,F);const o=L(Ft,F),a=new Float64Array(t.position.length),i=dt(t.position,r,o,a),l=O(_,o);return{position:i,normal:vt(t.normal,t.position,a,r,l),tangent:Mt(t.tangent,t.position,a,r,l)}}function I(t,e,n){j(t.spatialReference,[t.x,t.y,t.z||0],n,z(t.spatialReference));const{horizontal:r,vertical:o}=R(e?e.unit:null,t.spatialReference);return X(n,n,[r,r,o]),n}function dt(t,e,n,r){const o=it(t,e,r),a=f.fromTypedArray(o),i=new Float64Array(o.length),l=f.fromTypedArray(i);return A(l,a,n),i}function vt(t,e,n,r,o){if(h(t))return null;const a=lt(t,e,n,r,new Float32Array(t.length)),i=y.fromTypedArray(a);return T(i,i,o),a}function Mt(t,e,n,r,o){if(h(t))return null;const a=st(t,e,n,r,new Float32Array(t.length)),i=y.fromTypedArray(a,4*Float32Array.BYTES_PER_ELEMENT);return T(i,i,o),a}function R(t,e){if(h(t))return Rt;const n=e.isGeographic?1:et(e),r=e.isGeographic?1:rt(e),o=ot(1,t,"meters");return{horizontal:o*n,vertical:o*r}}const F=m(),Ft=m(),_=at(),Rt={horizontal:1,vertical:1};export{ft as L,mt as M,Lt as P,yt as _,Nt as k,x as r,P as x};
